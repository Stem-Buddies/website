<section class="w-full max-w-6xl mx-auto px-3">
  <div class="searchBoxContainer">
    <input
      type="text"
      id="searchBox"
      class="w-full px-2 py-1 border-2 border-black rounded-lg font-poppins"
      placeholder="Search..."
      data-test="search-input"
    />
  </div>

  <!-- Search Results -->
  <div id="searchResults" class="w-full pt-8 lg:pl-8 mt-12"></div>

  <!-- Search JS -->
  <script is:inline>
    let lunrIndex;
    let lunrResult;
    let pagesIndex;

    const bigramTokeniser = (obj, metadata) => {
      if (obj == null || obj == undefined) {
        return [];
      }

      let str = obj.toString().trim().toLowerCase();
      let tokens = [];

      for (let i = 0; i <= str.length - 2; i++) {
        let tokenMetadata = lunr.utils.clone(metadata) || {};
        tokenMetadata["position"] = [i, i + 2];
        tokenMetadata["index"] = tokens.length;
        tokens.push(new lunr.Token(str.slice(i, i + 2), tokenMetadata));
      }

      return tokens;
    };

    const queryNgramSeparator = (query) => {
      const str = query.toString().trim().toLowerCase();
      const tokens = [];

      for (let i = 0; i <= str.length - 2; i++) {
        tokens.push(str.slice(i, i + 2));
      }

      return tokens.join(" ");
    };

    const index = "/search-index.json";

    const initLunr = () => {
      let request = new XMLHttpRequest();
      request.open("GET", index, true);
      request.onload = function () {
        if (this.status >= 200 && this.status < 400) {
          pagesIndex = JSON.parse(this.response);
          lunrIndex = lunr(function () {
            this.tokenizer = bigramTokeniser;
            this.pipeline.reset();
            this.ref("slug");
            this.field("title", { boost: 10 });
            this.field("description", { boost: 5 });
            this.field("tags", { boost: 3 });
            this.field("body");
            this.metadataWhitelist = ["position"];
            pagesIndex.forEach((page) => {
              this.add(page);
            }, this);
          });
        } else {
          console.error("Error getting search index file");
        }
      };
      request.onerror = function () {
        console.error("connection error");
      };
      request.send();
    };

    const search = (query) => {
      lunrResult = lunrIndex.search(queryNgramSeparator(query));
      return lunrResult.map((result) => {
        return pagesIndex.filter((page) => {
          return page.slug === result.ref;
        })[0];
      });
    };

    const initUI = () => {
      const searchBox = document.querySelector("#searchBox");
      if (searchBox === null) {
        return;
      }

      let searchTimeout;
      
      searchBox.addEventListener("keyup", function (event) {
        const searchResultsArea = document.querySelector("#searchResults");
        if (!searchResultsArea) return;

        const target = event.target;
        let query = target.value;

        // Clear previous timeout
        clearTimeout(searchTimeout);

        // Only trigger a search when 2 chars. at least have been provided
        if (query.length < 2) {
          searchResultsArea.style.display = "none";
          return;
        }

        // Debounce search by 300ms
        searchTimeout = setTimeout(() => {
          renderResults(search(query));
          searchResultsArea.style.display = "block";
        }, 300);
      });
    };

    const renderResults = (results) => {
      const searchResults = document.querySelector("#searchResults");
      if (!searchResults) return;

      const searchBox = document.querySelector("#searchBox");
      if (!searchBox) return;

      const query = searchBox.value;
      const SNIPPET_LENGTH = 150;
      const MAX_PAGES = 10;

      // Debug: log results
      console.log("Search results:", results);

      // Clear search result
      while (searchResults.firstChild)
        searchResults.removeChild(searchResults.firstChild);

      // Show message when results is empty
      if (!results.length) {
        let resultPage = document.createElement("div");
        resultPage.className =
          "my-4 bg-white border border-black rounded-lg p-6 shadow-brutal flex flex-col gap-3";
        resultPage.innerHTML =
          '<div class="poppins text-lg">No results found for query "' +
          query +
          '"</div>';
        searchResults.append(resultPage);
        searchResults.style.display = "block";
        return;
      }

      searchResults.style.display = "block";

      let instance = new Mark(document.querySelector("#searchResults"));
      
      // Helper to strip markdown
      function stripMarkdown(text) {
        return text
          .replace(/[#*_`~\[\]>!-]/g, "") // remove markdown symbols
          .replace(/!\[[^\]]*\]\([^)]*\)/g, "") // remove images
          .replace(/\[[^\]]*\]\([^)]*\)/g, "") // remove links
          .replace(/\n+/g, " ") // newlines to space
          .replace(/\s+/g, " ") // collapse whitespace
          .trim();
      }

      // Helper to get better snippet around match
      function getBestSnippet(text, query, length = SNIPPET_LENGTH) {
        const cleanText = stripMarkdown(text);
        const queryWords = query.toLowerCase().split(/\s+/);
        
        // Find the best match position
        let bestPosition = 0;
        let bestScore = 0;
        
        for (let i = 0; i < cleanText.length - length; i++) {
          const snippet = cleanText.substr(i, length).toLowerCase();
          let score = 0;
          queryWords.forEach(word => {
            if (snippet.includes(word)) score++;
          });
          if (score > bestScore) {
            bestScore = score;
            bestPosition = i;
          }
        }
        
        let snippet = cleanText.substr(bestPosition, length);
        if (bestPosition > 0) snippet = "..." + snippet;
        if (bestPosition + length < cleanText.length) snippet += "...";
        
        return snippet;
      }

      // Helper to determine match types
      function getMatchTypes(metadata) {
        const types = [];
        for (const [term, fields] of Object.entries(metadata)) {
          for (const field of Object.keys(fields)) {
            if (!types.includes(field)) types.push(field);
          }
        }
        return types;
      }

      // Only show the ten first results
      results.slice(0, MAX_PAGES).forEach((result, idx) => {
        let resultPage = document.createElement("div");
        resultPage.className =
          "my-4 bg-white border border-black rounded-lg p-6 shadow-brutal flex flex-col gap-4 transition-all duration-150 hover:shadow-brutal-lg";
        
        const metadata = lunrResult[idx].matchData.metadata;
        const matchTypes = getMatchTypes(metadata);

        // Match type indicators
        if (matchTypes.length > 0) {
          let matchTypesDiv = document.createElement("div");
          matchTypesDiv.className = "flex gap-2 mb-2";
          
          matchTypes.forEach(type => {
            let badge = document.createElement("span");
            badge.className = "px-2 py-1 text-xs rounded bg-pink text-black font-medium";
            badge.innerText = type === "body" ? "content" : type;
            matchTypesDiv.append(badge);
          });
          
          resultPage.append(matchTypesDiv);
        }

        let resultTitle = document.createElement("a");
        resultTitle.className =
          "text-black text-2xl md:text-3xl font-bold leading-tight no-underline dm-serif transition-colors duration-150 hover:text-[#fd2d78] hover:underline";
        resultTitle.href = `/blog/${result.slug}`;
        resultTitle.innerText = stripMarkdown(result.title);
        resultPage.append(resultTitle);

        // Show description if available and different from title
        if (result.description && result.description !== result.title) {
          let resultDescription = document.createElement("div");
          resultDescription.className = "text-gray-600 text-sm poppins italic";
          resultDescription.innerText = stripMarkdown(result.description);
          resultPage.append(resultDescription);
        }

        // Show tags if available
        if (result.tags && result.tags.length > 0) {
          let tagsDiv = document.createElement("div");
          tagsDiv.className = "flex flex-wrap gap-1 mb-2";
          result.tags.forEach(tag => {
            let tagSpan = document.createElement("span");
            tagSpan.className = "px-2 py-1 text-xs bg-gray-200 text-gray-700 rounded cursor-pointer hover:bg-gray-300 transition-colors";
            tagSpan.innerText = tag;
            
            // Add click handler for tag filtering
            tagSpan.addEventListener("click", function() {
              const searchBox = document.querySelector("#searchBox");
              if (searchBox) {
                searchBox.value = tag;
                searchBox.dispatchEvent(new Event("keyup"));
              }
            });
            
            tagsDiv.append(tagSpan);
          });
          resultPage.append(tagsDiv);
        }

        let resultBody = document.createElement("div");
        resultBody.className =
          "text-gray-700 text-base poppins leading-relaxed";
        resultBody.innerText = getBestSnippet(result.body, query);
        resultPage.append(resultBody);
        
        searchResults.append(resultPage);

        instance.mark(query);
      });
    };

    initLunr();
    initUI();
  </script>

  <script is:inline>
    document.getElementById("searchBox")?.focus();
  </script>
</section>
